#include "node_3d.h"

// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
#define GLM_FORCE_DEPTH_ZERO_TO_ONE

#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"

#include "../../../common/io.h"
#include "../../../render/swap_chain.h"
#include "camera_3d.h"
#include "../sub_viewport.h"

#include <chrono>

namespace Flint {
    Node3D::Node3D() {
        type = NodeType::Node3D;

        mvp_buffer = std::make_shared<MvpBuffer>();
    }

    Node3D::~Node3D() {
    }

    void Node3D::_update(double delta) {
        update(delta);

        Node::_update(delta);
    }

    void Node3D::update(double delta) {
        update_mvp();
    }

    void Node3D::update_mvp() {
        // Prepare UBO data.
        UniformBufferObject ubo{};

        // Determined by model transform.
        ubo.model = glm::translate(glm::mat4(1.0f), glm::vec3(position.x, position.y, position.z));
        ubo.model = glm::scale(ubo.model, glm::vec3(scale.x, scale.y, scale.z));
        ubo.model = glm::rotate(ubo.model, (float) Engine::getSingleton().get_elapsed() * glm::radians(90.0f),
                                glm::vec3(0.0f, 0.0f, 1.0f));

        // FIXME: Should get camera from the viewport.
        // Determined by camera.
        Camera3D camera;
        camera.position = glm::vec3(2.0f, 2.0f, 2.0f);

        ubo.view = glm::lookAt(camera.position,
                               glm::vec3(0.0f, 0.0f, 0.0f),
                               camera.get_up_direction());

        Node *viewport_node = get_viewport();

        if (viewport_node) {
            auto viewport = dynamic_cast<SubViewport *>(viewport_node);

            // Set projection matrix. Determined by viewport.
            ubo.proj = glm::perspective(glm::radians(viewport->fov),
                                        (float) viewport->get_extent().x / (float) viewport->get_extent().y,
                                        viewport->z_near,
                                        viewport->z_far);

            // GLM was originally designed for OpenGL,
            // where the Y coordinate of the clip coordinates is inverted.
            ubo.proj[1][1] *= -1;
        } else {
            auto viewport_extent = SwapChain::getSingleton().swapChainExtent;

            // Set projection matrix. Determined by viewport.
            ubo.proj = glm::perspective(glm::radians(45.0f),
                                        (float) viewport_extent.width / (float) viewport_extent.height,
                                        0.1f,
                                        10.0f);

            // GLM was originally designed for OpenGL,
            // where the Y coordinate of the clip coordinates is inverted.
            ubo.proj[1][1] *= -1;
        }

        mvp_buffer->update_uniform_buffer(ubo);
    }

    void Node3D::_notify(Signal signal) {
        // We can intercept signal here.
        switch (signal) {
            case Signal::SwapChainChanged: {

            }
                break;
            default:
                break;
        }

        Node::_notify(signal);
    }
}
