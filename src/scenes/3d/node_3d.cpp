#include "node_3d.h"

// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
#define GLM_FORCE_DEPTH_ZERO_TO_ONE

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "../../common/io.h"
#include "../../rendering/swap_chain.h"
#include "camera_3d.h"
#include "../sub_viewport.h"

#include <chrono>

namespace Flint {
    Node3D::Node3D() {
        type = NodeType::Node3D;
    }

    Node3D::~Node3D() {
    }

    void Node3D::update(double delta) {
        // Branch to root.
        Node::update(delta);

        updateUniformBuffer();
    }

    void Node3D::createVertexBuffer(std::vector<Vertex> &vertices,
                                    VkBuffer &p_vertex_buffer,
                                    VkDeviceMemory &p_vertex_buffer_memory) {
        VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size();

        VkBuffer stagingBuffer; // In GPU
        VkDeviceMemory stagingBufferMemory; // In CPU

        // Create the GPU buffer and link it with the CPU memory.
        RS::getSingleton().createBuffer(bufferSize,
                                        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                                        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                                        stagingBuffer,
                                        stagingBufferMemory);

        // Copy data to the CPU memory.
        RS::getSingleton().copyDataToMemory(vertices.data(), stagingBufferMemory, bufferSize);

        // Create the vertex buffer (GPU) and bind it to the vertex memory (CPU).
        RS::getSingleton().createBuffer(bufferSize,
                                        VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                                        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                                        p_vertex_buffer,
                                        p_vertex_buffer_memory);

        // Copy buffer (GPU).
        RS::getSingleton().copyBuffer(stagingBuffer, p_vertex_buffer, bufferSize);

        // Clean up staging buffer and memory.
        vkDestroyBuffer(Device::getSingleton().device, stagingBuffer, nullptr);
        vkFreeMemory(Device::getSingleton().device, stagingBufferMemory, nullptr);
    }

    void Node3D::createIndexBuffer(std::vector<uint32_t> &indices,
                                   VkBuffer &p_index_buffer,
                                   VkDeviceMemory &p_index_buffer_memory) {
        VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

        VkBuffer stagingBuffer;
        VkDeviceMemory stagingBufferMemory;
        RS::getSingleton().createBuffer(bufferSize,
                                        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                                        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                                        stagingBuffer,
                                        stagingBufferMemory);

        RS::getSingleton().copyDataToMemory(indices.data(),
                                            stagingBufferMemory,
                                            bufferSize);

        RS::getSingleton().createBuffer(bufferSize,
                                        VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                                        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                                        p_index_buffer,
                                        p_index_buffer_memory);

        // Copy data from staging buffer to index buffer.
        RS::getSingleton().copyBuffer(stagingBuffer, p_index_buffer, bufferSize);

        vkDestroyBuffer(Device::getSingleton().device, stagingBuffer, nullptr);
        vkFreeMemory(Device::getSingleton().device, stagingBufferMemory, nullptr);
    }

    void Node3D::createUniformBuffers() {
        auto &swapChainImages = SwapChain::getSingleton().swapChainImages;

        VkDeviceSize bufferSize = sizeof(UniformBufferObject);

        uniformBuffers.resize(swapChainImages.size());
        uniformBuffersMemory.resize(swapChainImages.size());

        for (size_t i = 0; i < swapChainImages.size(); i++) {
            RS::getSingleton().createBuffer(bufferSize,
                                            VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
                                            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                                            uniformBuffers[i],
                                            uniformBuffersMemory[i]);
        }
    }

    void Node3D::updateUniformBuffer() {
        if (uniformBuffersMemory.empty()) return;

        // Prepare UBO data.
        UniformBufferObject ubo{};

        // Determined by model transform.
        ubo.model = glm::translate(glm::mat4(1.0f), glm::vec3(position.x, position.y, position.z));
        ubo.model = glm::scale(ubo.model, glm::vec3(scale.x, scale.y, scale.z));
        ubo.model = glm::rotate(ubo.model, (float) Engine::getSingleton().get_elapsed() * glm::radians(90.0f),
                                glm::vec3(0.0f, 0.0f, 1.0f));

        // FIXME: Should get camera from the viewport.
        // Determined by camera.
        Camera3D camera;
        camera.position = glm::vec3(2.0f, 2.0f, 2.0f);

        ubo.view = glm::lookAt(camera.position,
                               glm::vec3(0.0f, 0.0f, 0.0f),
                               camera.up);

        Node *viewport_node = get_viewport();

        if (viewport_node) {
            auto viewport = dynamic_cast<SubViewport *>(viewport_node);

            // Set projection matrix. Determined by viewport.
            ubo.proj = glm::perspective(glm::radians(viewport->fov),
                                        (float) viewport->extent.x / (float) viewport->extent.y,
                                        viewport->z_near,
                                        viewport->z_far);

            // GLM was originally designed for OpenGL,
            // where the Y coordinate of the clip coordinates is inverted.
            ubo.proj[1][1] *= -1;
        } else {
            auto viewport_extent = SwapChain::getSingleton().swapChainExtent;

            // Set projection matrix. Determined by viewport.
            ubo.proj = glm::perspective(glm::radians(45.0f),
                                        (float) viewport_extent.width / (float) viewport_extent.height,
                                        0.1f,
                                        10.0f);

            // GLM was originally designed for OpenGL,
            // where the Y coordinate of the clip coordinates is inverted.
            ubo.proj[1][1] *= -1;
        }

        // Copy the UBO data to the current uniform buffer.
        RS::getSingleton().copyDataToMemory(&ubo,
                                            uniformBuffersMemory[SwapChain::getSingleton().currentImage],
                                            sizeof(ubo));
    }

    void Node3D::notify(Signal signal) {
        Node::notify(signal);

        switch (signal) {
            case Signal::SwapChainChanged: {

            }
                break;
            default:
                break;
        }
    }
}
